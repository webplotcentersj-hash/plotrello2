BEGIN;

-- Tabla de impresoras
CREATE TABLE IF NOT EXISTS public.impresoras (
  id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nombre varchar(100) NOT NULL UNIQUE,
  modelo varchar(100),
  estado varchar(50) NOT NULL DEFAULT 'Disponible' CHECK (estado IN ('Disponible', 'En Uso', 'Mantenimiento', 'Fuera de Servicio')),
  capacidad_maxima_horas_dia numeric(10,2) DEFAULT 24.00,
  activa boolean DEFAULT true,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

-- Tabla de uso de impresoras (registra cuando una orden usa una impresora)
-- Nota: Esta tabla se crea sin foreign key a ordenes_trabajo inicialmente
-- La foreign key se puede agregar después si es necesario
CREATE TABLE IF NOT EXISTS public.impresora_uso (
  id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  id_impresora integer NOT NULL REFERENCES public.impresoras(id) ON DELETE CASCADE,
  id_orden integer NOT NULL,
  fecha_inicio timestamptz NOT NULL DEFAULT now(),
  fecha_fin timestamptz,
  horas_usadas numeric(10,2),
  estado varchar(50) NOT NULL DEFAULT 'En Proceso' CHECK (estado IN ('En Proceso', 'Completado', 'Cancelado')),
  operario varchar(100),
  created_at timestamptz DEFAULT now()
);

-- Agregar foreign key a ordenes_trabajo si la tabla existe
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'ordenes_trabajo') THEN
    -- Verificar si la constraint ya existe antes de agregarla
    IF NOT EXISTS (
      SELECT 1 FROM information_schema.table_constraints 
      WHERE constraint_schema = 'public' 
        AND table_name = 'impresora_uso' 
        AND constraint_name = 'impresora_uso_id_orden_fkey'
    ) THEN
      ALTER TABLE public.impresora_uso 
      ADD CONSTRAINT impresora_uso_id_orden_fkey 
      FOREIGN KEY (id_orden) REFERENCES public.ordenes_trabajo(id) ON DELETE CASCADE;
    END IF;
  END IF;
END $$;

-- Índices para mejorar el rendimiento
CREATE INDEX IF NOT EXISTS idx_impresora_uso_impresora ON public.impresora_uso(id_impresora);
CREATE INDEX IF NOT EXISTS idx_impresora_uso_orden ON public.impresora_uso(id_orden);
CREATE INDEX IF NOT EXISTS idx_impresora_uso_fecha_inicio ON public.impresora_uso(fecha_inicio);
CREATE INDEX IF NOT EXISTS idx_impresora_uso_estado ON public.impresora_uso(estado);
CREATE INDEX IF NOT EXISTS idx_impresoras_activa ON public.impresoras(activa);

-- Función para calcular horas usadas automáticamente
CREATE OR REPLACE FUNCTION public.calcular_horas_uso()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.fecha_fin IS NOT NULL AND NEW.fecha_inicio IS NOT NULL THEN
    NEW.horas_usadas := EXTRACT(EPOCH FROM (NEW.fecha_fin - NEW.fecha_inicio)) / 3600.0;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger para calcular horas automáticamente
-- Primero eliminar el trigger si ya existiera, para evitar error 42710
DROP TRIGGER IF EXISTS trigger_calcular_horas_uso ON public.impresora_uso;

CREATE TRIGGER trigger_calcular_horas_uso
BEFORE INSERT OR UPDATE ON public.impresora_uso
FOR EACH ROW
EXECUTE FUNCTION public.calcular_horas_uso();

-- Vista para calcular ocupación de impresoras basada en órdenes de Taller Gráfico
-- Solo crear la vista si las tablas necesarias existen
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'ordenes_trabajo')
     AND EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'impresoras') THEN
    
    -- Eliminar la vista si existe
    DROP VIEW IF EXISTS public.v_impresoras_ocupacion;
    
    -- Crear la vista completa
    EXECUTE $sql$
CREATE VIEW public.v_impresoras_ocupacion AS
WITH ordenes_taller_grafico AS (
  -- Obtener todas las órdenes que están actualmente en Taller Gráfico
  SELECT 
    ot.id as id_orden,
    ot.numero_op,
    ot.cliente,
    ot.sector,
    ot.estado,
    -- Encontrar cuándo entró a Taller Gráfico (por sector o por estado)
    COALESCE(
      (
        SELECT MIN(hm.timestamp)
        FROM public.historial_movimientos hm
        WHERE hm.id_orden = ot.id
          AND (hm.estado_nuevo = 'Taller Gráfico' OR hm.estado_nuevo LIKE '%Taller Gráfico%')
        ORDER BY hm.timestamp ASC
        LIMIT 1
      ),
      ot.fecha_ingreso
    ) as fecha_entrada_taller,
    -- Determinar si está actualmente en Taller Gráfico
    CASE 
      WHEN ot.sector = 'Taller Gráfico' 
           AND ot.estado NOT IN ('Entregado o Instalado', 'Finalizado en Taller', 'Almacén de Entrega') 
           AND ot.estado != 'Pendiente' THEN true
      ELSE false
    END as en_taller_actualmente,
    -- Calcular tiempo estimado de procesamiento basado en complejidad (horas)
    CASE 
      WHEN ot.complejidad = 'Alta' THEN 4.0
      WHEN ot.complejidad = 'Media' THEN 2.0
      ELSE 1.0
    END as tiempo_estimado_horas
  FROM public.ordenes_trabajo ot
  WHERE ot.sector = 'Taller Gráfico'
     AND ot.estado NOT IN ('Entregado o Instalado', 'Finalizado en Taller', 'Almacén de Entrega')
     AND ot.estado != 'Pendiente'
),
-- Contar total de impresoras activas
total_impresoras AS (
  SELECT COUNT(*) as total
  FROM public.impresoras
  WHERE activa = true
),
-- Distribuir órdenes entre impresoras (round-robin basado en ID de orden)
ordenes_por_impresora AS (
  SELECT 
    otg.*,
    i.id as id_impresora,
    i.nombre as nombre_impresora,
    -- Calcular horas para hoy: si está en taller, usar tiempo desde entrada o tiempo estimado
    CASE 
      WHEN otg.en_taller_actualmente THEN
        -- Si entró hoy, calcular horas transcurridas
        CASE 
          WHEN DATE(otg.fecha_entrada_taller) = CURRENT_DATE THEN
            GREATEST(
              EXTRACT(EPOCH FROM (CURRENT_TIMESTAMP - otg.fecha_entrada_taller)) / 3600.0,
              otg.tiempo_estimado_horas * 0.1  -- Mínimo 10% del tiempo estimado
            )
          ELSE
            -- Si entró antes de hoy, contar solo las horas de hoy
            GREATEST(
              EXTRACT(EPOCH FROM (CURRENT_TIMESTAMP - DATE_TRUNC('day', CURRENT_TIMESTAMP))) / 3600.0,
              otg.tiempo_estimado_horas * 0.1
            )
        END
      ELSE 0
    END as horas_hoy,
    -- Calcular horas para esta semana
    CASE 
      WHEN otg.en_taller_actualmente THEN
        CASE 
          WHEN otg.fecha_entrada_taller >= DATE_TRUNC('week', CURRENT_DATE) THEN
            GREATEST(
              EXTRACT(EPOCH FROM (CURRENT_TIMESTAMP - otg.fecha_entrada_taller)) / 3600.0,
              otg.tiempo_estimado_horas * 0.1
            )
          ELSE
            -- Si entró antes de esta semana, contar solo las horas de esta semana
            GREATEST(
              EXTRACT(EPOCH FROM (CURRENT_TIMESTAMP - DATE_TRUNC('week', CURRENT_DATE))) / 3600.0,
              otg.tiempo_estimado_horas * 0.1
            )
        END
      ELSE 0
    END as horas_semana
  FROM ordenes_taller_grafico otg
  CROSS JOIN public.impresoras i
  CROSS JOIN total_impresoras ti
  WHERE i.activa = true
    -- Distribuir órdenes entre impresoras usando módulo (round-robin)
    AND (otg.id_orden % NULLIF(ti.total, 0)) = ((i.id - 1) % NULLIF(ti.total, 1))
)
SELECT 
  i.id,
  i.nombre,
  i.modelo,
  i.estado as estado_impresora,
  i.capacidad_maxima_horas_dia,
  i.activa,
  -- Horas usadas hoy
  COALESCE(SUM(opp.horas_hoy), 0) as horas_usadas_hoy,
  -- Horas usadas esta semana
  COALESCE(SUM(opp.horas_semana), 0) as horas_usadas_semana,
  -- Porcentaje de ocupación hoy
  CASE 
    WHEN i.capacidad_maxima_horas_dia > 0 THEN
      LEAST(100, (COALESCE(SUM(opp.horas_hoy), 0) / i.capacidad_maxima_horas_dia) * 100)
    ELSE 0
  END as porcentaje_ocupacion_hoy,
  -- Porcentaje de ocupación esta semana
  CASE 
    WHEN i.capacidad_maxima_horas_dia > 0 THEN
      LEAST(100, (COALESCE(SUM(opp.horas_semana), 0) / (i.capacidad_maxima_horas_dia * 7)) * 100)
    ELSE 0
  END as porcentaje_ocupacion_semana,
  -- Contar trabajos activos (órdenes actualmente en Taller Gráfico asignadas a esta impresora)
  COUNT(CASE WHEN opp.en_taller_actualmente THEN 1 END) as trabajos_activos
FROM public.impresoras i
LEFT JOIN ordenes_por_impresora opp ON i.id = opp.id_impresora
WHERE i.activa = true
GROUP BY i.id, i.nombre, i.modelo, i.estado, i.capacidad_maxima_horas_dia, i.activa;
    $sql$;
  ELSE
    -- Si las tablas no existen, crear una vista simple que solo muestre las impresoras
    DROP VIEW IF EXISTS public.v_impresoras_ocupacion;
    
    EXECUTE $sql$
CREATE VIEW public.v_impresoras_ocupacion AS
SELECT 
  i.id,
  i.nombre,
  i.modelo,
  i.estado as estado_impresora,
  i.capacidad_maxima_horas_dia,
  i.activa,
  0 as horas_usadas_hoy,
  0 as horas_usadas_semana,
  0 as porcentaje_ocupacion_hoy,
  0 as porcentaje_ocupacion_semana,
  0 as trabajos_activos
FROM public.impresoras i
WHERE i.activa = true;
    $sql$;
  END IF;
END $$;

-- Insertar algunas impresoras de ejemplo (puedes modificar o eliminar esto)
INSERT INTO public.impresoras (nombre, modelo, estado, capacidad_maxima_horas_dia, activa)
VALUES
  ('Impresora 1', 'HP DesignJet', 'Disponible', 24.00, true),
  ('Impresora 2', 'Canon ImagePROGRAF', 'Disponible', 24.00, true),
  ('Impresora 3', 'Epson SureColor', 'Disponible', 24.00, true)
ON CONFLICT (nombre) DO NOTHING;

-- Permisos
GRANT SELECT ON public.impresoras TO anon, authenticated;
GRANT SELECT ON public.impresora_uso TO anon, authenticated;
GRANT SELECT ON public.v_impresoras_ocupacion TO anon, authenticated;
GRANT INSERT, UPDATE ON public.impresora_uso TO authenticated;

COMMIT;

